----------------------------------------------------------------------------------------------------
-- Script switching logic
----------------------------------------------------------------------------------------------------
-- Разработчик: Andrey Fidrya(Zmey) af@svitonline.com
----------------------------------------------------------------------------------------------------

ini_dummy_ltx = ini_file([[scripts\dummy.ltx]])

local lokas = {
  marsh=1,
  aver=6,
  generators=7,
  hospital=2,
  limansk=8,
  lost_village=2,
  red_forest=7,
  av_peshera=6,
  warlab=7,
  l01_escape=1,
  k01_darkscape=2,
  l02_garbage=3,
  l03_agroprom=4,
  l03u_agr_underground=4,
  l04_darkvalley=3,
  l04u_labx18=6,
  labx8=6,
  l05_bar=5,
  l06_rostok=6,
  l07_military=6,
  l08_yantar=6,
  l08u_brainlab=7,
  l10_radar=7,
  l10u_bunker=7,
  l11_pripyat=9,
  l12_stancia_new=9,
  l12_stancia_2_new=9,
  l12u_control_monolith=9,
  l12u_sarcofag=9
}
local rangs = {
  novice=1,
  weak=1,
  experienced=2,
  normal=2,
  veteran=3,
  strong=3,
  master=4
}
function configure_schemes(npc, ini, ini_filename, stype, section_logic, gulag_name)
  local npc_id = npc:id()
  local st = db.storage[npc_id]
  -- если какая-то схема была до этого активна, деактивировать её
  if st and st.active_section then
    issue_event(npc, st[st.active_scheme], "deactivate", npc)
  end

  local actual_ini
  local actual_ini_filename
  if not ini:section_exist(section_logic) then
    if not gulag_name then
      actual_ini_filename = ini_filename
      actual_ini = ini
    else
      -- Иначе это персонаж Gulag-а и ему не задали работу:
      ODS("[~T].~C0CERROR: object '%s': unable to find section '%s'", npc:name(), section_logic)
    end
  else
    local filename = utils.cfg_get_string(ini, section_logic, "cfg", npc, false, "")
    if filename then
      actual_ini_filename = filename
      actual_ini = ini_file(filename)
      return configure_schemes(npc, actual_ini, actual_ini_filename, stype, section_logic, gulag_name)
    else
      actual_ini_filename = ini_filename
      actual_ini = ini
    end
  end

  -- Поскольку в момент активации схемы могли работать ранее установленные общие схемы, нужно их все отключить:
  disable_generic_schemes(npc, stype)
  -- Включаем все общие схемы(раненный, коллбек на попадание и т.д.):
  enable_generic_schemes(actual_ini, npc, stype, section_logic)

  -- Инициализация торговли
  if stype==modules.stype_stalker or npc:clsid()==CLID_TRADER then
  
  local difficult=level.get_game_difficulty()
  local npc_group = npc:character_community()
  local trade_ini
  if npc:story_id()<10000 then
  trade_ini = utils.cfg_get_string(actual_ini, section_logic, "trade", npc, false, "", "misc\\trade_logic\\trade_generic_kv.ltx")
  else
    if xr_wounded.is_wounded(npc) then
    trade_ini = utils.cfg_get_string(actual_ini, section_logic, "trade", npc, false, "", "misc\\trade_logic\\trade_generic_wnd.ltx")
    else
      if npc_group=="military" then
      trade_ini = utils.cfg_get_string(actual_ini, section_logic, "trade", npc, false, "", "misc\\trade_logic\\trade_generic_mil.ltx")
      elseif npc_group=="green" then
      trade_ini = utils.cfg_get_string(actual_ini, section_logic, "trade", npc, false, "", "misc\\trade_logic\\trade_generic_grn.ltx")
      elseif npc_group=="freedom" then
      trade_ini = utils.cfg_get_string(actual_ini, section_logic, "trade", npc, false, "", "misc\\trade_logic\\trade_generic_frd.ltx")
      elseif npc_group=="bandit" then
      trade_ini = utils.cfg_get_string(actual_ini, section_logic, "trade", npc, false, "", "misc\\trade_logic\\trade_generic_bnd.ltx")
      elseif npc_group=="dolg" then
      trade_ini = utils.cfg_get_string(actual_ini, section_logic, "trade", npc, false, "", "misc\\trade_logic\\trade_generic_dlg.ltx")
      elseif npc_group=="ecolog" then
      trade_ini = utils.cfg_get_string(actual_ini, section_logic, "trade", npc, false, "", "misc\\trade_logic\\trade_generic_ecl.ltx")
      else
        local lname = level.name()
        local lok_trade = tostring(lokas[lname])
        local gg_rank = tostring(rangs[ranks.get_obj_rank_name(db.actor)])
        local npc_rank = tostring(rangs[ranks.get_obj_rank_name(npc)])
        trade_ini = utils.cfg_get_string(actual_ini, section_logic, "trade", npc, false, "", "misc\\trade_logic\\trade_generic_"..lok_trade..npc_rank..gg_rank..".ltx")
      end
    end
  end
  trade_manager.trade_init(npc, trade_ini)
  end

  st.active_section = nil
  st.active_scheme = nil
  if gulag_name then
    st.gulag_name = gulag_name
  else
    st.gulag_name = ""
  end
  st.stype = stype
  st.ini = actual_ini
  st.ini_filename = actual_ini_filename
  st.section_logic = section_logic

  return st.ini
end

-- Вызывается биндером с целью определить первую активную схему
function determine_section_to_activate(npc, ini, section_logic, actor)
  if not ini:section_exist(section_logic) then
    return "nil"
  end
   -- Распарсить строку выбора активной секции с учетом команд, заключенных в %%
  local active_section_cond = cfg_get_condlist(ini, section_logic, "active", npc)
  local active_section
   if not active_section_cond then
    --ODS("[~T].~C0Cobject '%s': section '%s': unable to find field 'active'", npc:name(), section_logic)
  else
    active_section = pick_section_from_condlist(actor, npc, active_section_cond.condlist)
    if not active_section then
      --ODS("[~T].~C0Cobject '%s': section '%s': section 'active' has no conditionless else clause", npc:name(), section_logic)
    end
  end
    ElapsedTime(23)
    
    local id = npc:id()
    local slot = db.storage[id]
   
  if active_section and slot.stype and 
                          slot.stype <= 1 and 
                          slot.stype ~= stypes[ utils.get_scheme_by_section(active_section) ] then
  -- Блокируем активацию схемы для зверушек в человеческих гулагах. Dirty Hack.   
    return "nil"
  else 
        return active_section
  end
end

------------------------------------------------------------------------------------------------------------
-- ВНОСЯ ИЗМЕНЕНИЯ В ЭТУ ФУНКЦИЮ, НЕ ЗАБЫВАЙТЕ ДОБАВЛЯТЬ СООТВЕТСТВУЮЩИЕ СТРОКИ И В enable_generic_schemes
------------------------------------------------------------------------------------------------------------
function disable_generic_schemes(npc, stype)
  if stype==modules.stype_stalker then
    xr_combat.disable_scheme(npc, "combat")
    xr_punch_tm.disable_scheme(npc, "punch_tm")
    xrs_ai.disable_schemes(npc, stype)
    if rx_ai then rx_ai.disable_schemes(npc, stype) end
    xr_use.disable_scheme(npc, "use")
    xr_hit.disable_scheme(npc, "hit")
    xr_meet.disable_scheme(npc, "actor_dialogs")
    xr_heli_hunter.disable_scheme(npc, "heli_hunter")
    xr_companion.disable_scheme(npc, "companion")
    xr_combat_ignore.disable_scheme(npc, "combat_ignore")
  elseif stype==modules.stype_mobile then
    mob_combat.disable_scheme(npc, "mob_combat")
    mob_trade.disable_scheme(npc, "mob_trade")
  elseif stype==modules.stype_item then
    ph_on_hit.disable_scheme(npc, "ph_on_hit")
  elseif stype==modules.stype_heli then
    xr_hit.disable_scheme(npc, "hit")
  end
end

------------------------------------------------------------------------------------------------------------
-- ВНОСЯ ИЗМЕНЕНИЯ В ЭТУ ФУНКЦИЮ, НЕ ЗАБЫВАЙТЕ ДОБАВЛЯТЬ СООТВЕТСТВУЮЩИЕ СТРОКИ И В disable_generic_schemes
------------------------------------------------------------------------------------------------------------
function enable_generic_schemes(ini, npc, stype, section)
  if stype==modules.stype_stalker then
    if blowout_scheme then blowout_scheme.set_hide(npc,ini,"blowout_scheme",section) end

    --xr_reactions.set_reactions(npc, ini, "reactions", section)
    xr_danger.set_danger(npc, ini, "danger", "danger")
    local combat_section = utils.cfg_get_string(ini, section, "on_combat", npc, false, "")
    xr_combat.set_combat_checker(npc, ini, "combat", combat_section)

    local use_section = utils.cfg_get_string(ini, section, "on_use", npc, false, "")
    if use_section then
      xr_use.set_use_checker(npc, ini, "use", use_section)
    end
    local info_section = utils.cfg_get_string(ini, section, "info", npc, false, "")
    if info_section then
      stalker_generic.set_npc_info(npc, ini, "info", info_section)
    end

    local hit_section = utils.cfg_get_string(ini, section, "on_hit", npc, false, "")
    if hit_section then
      xr_hit.set_hit_checker(npc, ini, "hit", hit_section)
    end

    local wounded_section = utils.cfg_get_string(ini, section, "wounded", npc, false, "")
    xr_wounded.set_wounded(npc, ini, "wounded", wounded_section)

    xr_abuse.set_abuse(npc, ini, "abuse", section)

    local meet_section = utils.cfg_get_string(ini, section, "meet", npc, false, "")
    xr_meet.set_meet(npc, ini, "meet", meet_section)

    local death_section = utils.cfg_get_string(ini, section, "on_death", npc, false, "")
    xr_death.set_death(npc, ini, "death", death_section)

    local heli_hunter_section = utils.cfg_get_string(ini, section, "heli_hunter", npc, false, "")
    xr_heli_hunter.set_scheme(npc, ini, "heli_hunter", heli_hunter_section)

    local combat_ignore_section = utils.cfg_get_string(ini, section, "combat_ignore", npc, false, "")
    if combat_ignore_section then
      xr_combat_ignore.set_combat_ignore_checker(npc, ini, "combat_ignore", combat_ignore_section)
    end
    
    local companion_section = utils.cfg_get_string(ini, section, "companion", npc, false, "")
    if companion_section then
    xr_companion.set_scheme(npc, ini, "companion",companion_section)
    end
        if _G.watcher_act == nil then
           abort(" watcher_act.script was not loaed ")
        end        
    watcher_act.set_scheme(npc,ini,"watcher_act","watcher_act") -- проблема здесь если скрипт не загружается!
    xr_punch_tm.set_scheme(npc, nil, "punch_tm")
    xrs_ai.enable_schemes(ini, npc, stype, section)
  if rx_ai then rx_ai.enable_schemes(ini,npc) end
  elseif stype==modules.stype_mobile then
    local combat_section = utils.cfg_get_string(ini, section, "on_combat", npc, false, "")
    if combat_section then
      mob_combat.set_scheme(npc, ini, "mob_combat", combat_section)
    end

    local death_section = utils.cfg_get_string(ini, section, "on_death", npc, false, "")
    mob_death.set_scheme(npc, ini, "mob_death", death_section)

    local trade_section = utils.cfg_get_string(ini, section, "on_trade", npc, false, "")
    if trade_section then
      mob_trade.set_scheme(npc, ini, "mob_trade", trade_section)
    end

    local hit_section = utils.cfg_get_string(ini, section, "on_hit", npc, false, "")
    if hit_section then
      xr_hit.set_hit_checker(npc, ini, "hit", hit_section)
    end

    mob_panic.set_scheme(npc, ini, "mob_panic")

  elseif stype==modules.stype_item then
    local hit_section = utils.cfg_get_string(ini, section, "on_hit", npc, false, "")
    ----printf("HIT SECTION [%s]", tostring(hit_section))
    if hit_section then
      ph_on_hit.set_scheme(npc, ini, "ph_on_hit", hit_section)
    end

  elseif stype==modules.stype_heli then
    local hit_section = utils.cfg_get_string(ini, section, "on_hit", npc, false, "")
    if hit_section then
      xr_hit.set_hit_checker(npc, ini, "hit", hit_section)
    end
  end
end

function activate_by_section(npc, ini, section, loading)
  local npc_id = npc:id()
  if db.storage[npc_id].active_section then
    --ODS("[~T].~C0Cxr_logic: activate_by_section: while processing section "..section..": character "..npc:name()..": trying to activate more than one schemes at once(section "..db.storage[npc_id].active_section.." is active)")
  end

  if not loading then
    db.storage[npc_id].activation_time = time_global()
    db.storage[npc_id].activation_game_time = game.get_game_time()
  end

  if section=="nil" or section==nil then
    db.storage[npc_id].overrides = nil
    reset_generic_schemes_on_scheme_switch(npc, "nil", "nil")
    db.storage[npc_id].active_section = nil
    db.storage[npc_id].active_scheme = nil
--'  db.storage[npc_id].pstor = nil
    return
  end

  if ini:section_exist(section) then
      local scheme = utils.get_scheme_by_section(section)
    db.storage[npc_id].overrides = cfg_get_overrides(ini, section, npc)
    reset_generic_schemes_on_scheme_switch(npc, scheme, section)
    local filename = schemes[scheme]
    -- wprintf ("[~T]. #DBG: xr_logic:~C0F %-30s~C07 : scheme~C0E %-15s~C07, activated from section~C0A %s~C07", npc:name(), scheme, section)
        if _G[filename] then         
       _G[filename].set_scheme(npc, ini, scheme, section, db.storage[npc_id]["gulag_name"])
        else
           wprintf("[~T].~C0C #ERROR(xr_logic.script):~C0F _G.%s~C07 == nil for scheme~C0E %s~C07", filename or 'nil', scheme or 'nil')
        end   
           
    db.storage[npc_id].active_section = section
    db.storage[npc_id].active_scheme = scheme
    if db.storage[npc_id].stype==modules.stype_stalker then
      utils.send_to_nearest_accessible_vertex(npc, npc:level_vertex_id())
      issue_event(npc, db.storage[npc_id][scheme], "activate_scheme", loading, npc)
    else
      issue_event(npc, db.storage[npc_id][scheme], "reset_scheme", loading, npc)
    end
  else
    --ODS("[~T].~C0Cobject "..npc:name()..": activate_by_section: section '%s' does not exist"..section)
  end
end

--[[
-- Предназначение:
--  Производит сброс состояния объекта(снимает коллбеки, отключает разговор) непосредственно перед включением
--  новой схемы.
--]]
function reset_generic_schemes_on_scheme_switch(npc, scheme, section)
  local st = db.storage[npc:id()]

  if not st.stype then
    return
  end

  if st.stype==modules.stype_stalker then
  
    --xr_reactions.reset_reactions(npc, scheme, st, section)
    xr_meet.dialog_manager_reset(npc, st.stype)
    xr_meet.reset_meet(npc, scheme, st, section)
    xr_abuse.reset_abuse(npc, scheme, st, section)
    xr_wounded.reset_wounded(npc, scheme, st, section)
    xr_death.reset_death(npc, scheme, st, section)
    xr_danger.reset_danger(npc, scheme, st, section)
    stalker_generic.reset_threshold(npc, scheme, st, section)
    stalker_generic.reset_show_spot(npc, scheme, st, section)
	if rx_ai then rx_ai.reset_schemes(npc, scheme, st, section) end
  elseif st.stype==modules.stype_mobile then
    xr_meet.dialog_manager_reset(npc, st.stype)
    mob_release(npc)
    if get_clsid(npc)==CLID_BLOODSUCKER then
      if scheme=="nil" then
        npc:set_manual_invisibility(false)
      else
        npc:set_manual_invisibility(true)
        --npc:set_invisible(false)
      end
    end
    mob_panic.reset_panic(npc, scheme, st, section)
  elseif st.stype==modules.stype_item then
    npc:set_callback(callback.use_object, nil)
    npc:set_nonscript_usable(true)
    --[[if get_clsid(npc)==clsid.car then
      npc:destroy_car()
      mob_release(npc)
    end--]]
  end
end

function assign_storage_and_bind(npc, ini, scheme, section)
  local npc_id = npc:id()
    
  local st
  if db.storage[npc_id][scheme] then
       st = db.storage[npc_id][scheme]
     -- ODS("[~T/~B]. #DBG: бинд объект ~C0A"..tostring(npc:name()).."~C07","f")
       -- wprintf ("[~T/~U/~B].~C09 #DBG: updating scheme st ~C09 %-30s %-50s pst = %.5f ~C07", scheme, nnm, elps)
    else   
    db.storage[npc_id][scheme] = {}
    st = db.storage[npc_id][scheme]
        st.npc = npc    
    if st and ini then
      -- ODS("[~T/~B]. #DBG: бинд объект ~C0A"..tostring(npc:name()).."~C07","f")  
      _G[schemes[scheme]].add_to_binder(npc, ini, scheme, section, st) 
    end
  end
    st.scheme = scheme
    st.section = section
    st.ini = ini
  return st
end

function subscribe_action_for_events(npc, storage, new_action)
  if not storage.actions then
    storage.actions = {}
  end
  storage.actions[new_action] = true
end

function unsubscribe_action_from_events(npc, storage, new_action)
  if not storage.actions then
    storage.actions = {}
  end
  storage.actions[new_action] = nil
end

function issue_event(npc, st, event_fn, ...)
  if not npc or not st or not st.actions then
    return
  end

  local activation_count = 0
  local action_ptr, is_active = 0, 0

  for action_ptr, is_active in pairs(st.actions) do
    if is_active and action_ptr[event_fn] then
      action_ptr[event_fn](action_ptr, ...)
      activation_count = activation_count + 1
    end
  end
end

function pick_section_from_condlist(actor, npc, condlist)
  local rval = nil -- lua_random(100)
  local newsect = nil
  local infop_conditions_met
  for n, cond in pairs(condlist) do
    infop_conditions_met = true -- изначально считаем, что все условия переключения удовлетворены
    for inum, infop in pairs(cond.infop_check) do
      if infop.prob then
        if not rval then
          rval = lua_random(100)
        end
        if infop.prob < rval then
          infop_conditions_met = false -- инфопоршен есть, но он не должен присутствовать
          break
        end
      elseif infop.func then
        if not xr_conditions[infop.func] then
          --ODS("[~T].~C0Cobject '%s': pick_section_from_condlist: function '%s' is not defined in xr_conditions.script", npc:name(), infop.func)
        end
        --if xr_conditions[infop.func](actor, npc) then
        if infop.params then
          if xr_conditions[infop.func](actor, npc, infop.params) then
            if not infop.expected then
              infop_conditions_met = false -- инфопоршен есть, но не должен присутствовать
              break
            end
          else
            if infop.expected then
              infop_conditions_met = false -- инфопоршен есть, но не должен присутствовать
              break
            end
          end
        else
    --sak.dbglog("infop.func = %s",infop.func)
          if xr_conditions[infop.func](actor, npc) then
            if not infop.expected then
              infop_conditions_met = false -- инфопоршен есть, но не должен присутствовать
              break
            end
          else
            if infop.expected then
              infop_conditions_met = false -- инфопоршен есть, но не должен присутствовать
              break
            end
          end
        end
      elseif has_alife_info(infop.name) then
        if not infop.required then
          infop_conditions_met = false -- инфопоршен есть, но он не должен присутствовать
          break
        end
      else
        if infop.required then
          infop_conditions_met = false -- инфопоршена нет, но он нужен
          break
        end
      end
    end
    if infop_conditions_met then
      -- Условия выполнены. Независимо от того, задана ли секция, нужно проставить требуемые
      for inum, infop in pairs(cond.infop_set) do
        if db.actor==nil then
          ODS("[~T].~C0CTRYING TO SET INFOS THEN ACTOR IS NIL")
        end
        if infop.func then
          local func=nil
          local module,fname=string.match(infop.func,"(.+)[.](.+)")
          --ODS("[~T].~C0Cobject ".. tostring(infop.func).." module ".. tostring(module).." fname "..tostring(fname))
          if not fname then
            func=xr_effects[infop.func]
          else
            if _G[module] and _G[module][fname] then
              func=_G[module][fname]
            end
          end
          if func then                      
              if infop.params then
                func(actor, npc, infop.params)
              else
                func(actor, npc)
                end
                    else        
                       local npc_name = 'nil'
                       if npc then npc_name = npc:name() end
                       --abort( sprintf(" object '%s': pick_section_from_condlist: function '%s' is not defined ", npc_name, infop.func ) )
                    end
                 
        elseif infop.required then
          if not has_alife_info(infop.name) then
            actor:give_info_portion(infop.name)
          end
        else
          if has_alife_info(infop.name) then
            actor:disable_info_portion(infop.name)
          end
        end
      end
      if cond.section=="never" then
        return nil
      else
        return cond.section
      end
    end
  end
  return nil
end

-- Выполняет переключение на указанную секцию, если задана.
-- Если section==nil, остается работать старая секция.
function switch_to_section(npc, st, section)
  if section==nil or section=="" then
    return false
  end
  --if (section=="sr_aes_deadzone") then
  --if (has_alife_info("strelok_pda_have")) then
  --return false
  --end
  --end
  local active_section = db.storage[npc:id()].active_section
  if active_section==section then
    return false
  end
  -- call scheme::finalize()
  if active_section then
    issue_event(npc, db.storage[npc:id()][db.storage[npc:id()].active_scheme], "deactivate", npc)
  end
  db.storage[npc:id()].active_section = nil
  db.storage[npc:id()].active_scheme = nil
  activate_by_section(npc, st.ini, section, false)
  return true
end

function see_actor(npc)
  return npc:alive() and npc:see(db.actor)
end

function cond_name(cond, etalon)
  return string.find(cond, "^"..etalon.."%d*$")~=nil
end

function try_switch_to_another_section(npc, st, actor)
  local l = st.logic
  local npc_id = npc:id()

  if not actor then
    --ODS("[~T].~C0Ctry_switch_to_another_section(): error in implementation of scheme '%s': actor is nil", st.scheme)
    return
  end

  if not l then
    --ODS("[~T].~C0CCan't find script switching information in storage, scheme '%s'", st.active_scheme)
  end

  local switched = false
  for n, c in pairs(l) do
    if cond_name(c.name, "on_info") then
      switched = switch_to_section(npc, st, pick_section_from_condlist(actor, npc, c.condlist))
    elseif cond_name(c.name, "on_timer") then
      if time_global() >= db.storage[npc_id].activation_time + c.v1 then
        switched = switch_to_section(npc, st, pick_section_from_condlist(actor, npc, c.condlist))
      end
    elseif cond_name(c.name, "on_actor_inside") then
      if utils.npc_in_zone(actor, npc) then
        switched = switch_to_section(npc, st, pick_section_from_condlist(actor, npc, c.condlist))
      end
    elseif cond_name(c.name, "on_actor_outside") then
      if not utils.npc_in_zone(actor, npc) then
        switched = switch_to_section(npc, st, pick_section_from_condlist(actor, npc, c.condlist))
      end
    elseif cond_name(c.name, "on_signal") then
      if st.signals and st.signals[c.v1] then
        switched = switch_to_section(npc, st, pick_section_from_condlist(actor, npc, c.condlist))
      end
    elseif cond_name(c.name, "on_actor_dist_le") then
      if see_actor(npc) and distance_between(actor, npc) <= c.v1 then
        switched = switch_to_section(npc, st, pick_section_from_condlist(actor, npc, c.condlist))
      end
    elseif cond_name(c.name, "on_actor_dist_le_nvis") then
      if distance_between(actor, npc) <= c.v1 then
        switched = switch_to_section(npc, st, pick_section_from_condlist(actor, npc, c.condlist))
      end
    elseif cond_name(c.name, "on_actor_dist_ge") then
      if see_actor(npc) and distance_between(actor, npc) > c.v1 then
        switched = switch_to_section(npc, st, pick_section_from_condlist(actor, npc, c.condlist))
      end
    elseif cond_name(c.name, "on_actor_dist_ge_nvis") then
      if distance_between(actor, npc) > c.v1 then
        switched = switch_to_section(npc, st, pick_section_from_condlist(actor, npc, c.condlist))
      end
    elseif cond_name(c.name, "on_game_timer") then
      if  game.get_game_time():diffSec(db.storage[npc_id].activation_game_time) >= c.v1 then
        switched = switch_to_section(npc, st, pick_section_from_condlist(actor, npc, c.condlist))
      end
    elseif cond_name(c.name, "on_actor_in_zone") then
      if utils.npc_in_zone(actor, db.zone_by_name[c.v1]) then
        switched = switch_to_section(npc, st, pick_section_from_condlist(actor, npc, c.condlist))
      end
    elseif cond_name(c.name, "on_actor_not_in_zone") then
      if not utils.npc_in_zone(actor, db.zone_by_name[c.v1]) then
        switched = switch_to_section(npc, st, pick_section_from_condlist(actor, npc, c.condlist))
      end
    elseif cond_name(c.name, "on_npc_in_zone") then
      if utils.npc_in_zone(client_obj(c.npc_id), db.zone_by_name[c.v2]) then
        switched = switch_to_section(npc, st, pick_section_from_condlist(actor, npc, c.condlist))
      end
    elseif cond_name(c.name, "on_npc_not_in_zone") then
      if not utils.npc_in_zone(client_obj(c.npc_id), db.zone_by_name[c.v2]) then
        switched = switch_to_section(npc, st, pick_section_from_condlist(actor, npc, c.condlist))
      end
    
    else
      --ODS("[~T].~C0CWARNING: object '%s': try_switch_to_another_section: unknown condition '%s' encountered",npc:name(), c.name)
    end
    if switched then
      break
    end
  end
  return switched
end

function is_active(npc, st)
  if st.section==nil then
    --ODS("[~T].~C0Cnpc "..npc:name()..": st.section is nil, active section is "..utils.to_str(db.storage[npc:id()].active_section))
  end
  local is_act =(st.section==db.storage[npc:id()].active_section)
  return is_act
end


function abort_syntax_error_in_cond(npc, section, field)
  --ODS("[~T].~C0Cobject '%s': section '%s': field '%s': syntax error in switch condition",npc:name(), section, field)
end

-- На входе имеем пустой массив и строку вида "  +infop1  -infop2 +infop3 ... "
-- Заполнить массив:
-- {"infop_name" = true/false }.
function parse_infop1(rslt, str)
  if str then
    local infop_name, sign
    local infop_n = 1
    for s in string.gfind(str, "%s*([%-%+%~%=%!][^%-%+%~%=%!%s]+)%s*") do
      sign = string.sub(s, 1, 1)
      infop_name = string.sub(s, 2)
      if sign=="+" then
        rslt[infop_n] = {name = infop_name, required = true }
      elseif sign=="-" then
        rslt[infop_n] = {name = infop_name, required = false }
      elseif sign=="~" then
        rslt[infop_n] = {prob = tonumber(infop_name) }
      elseif sign=="=" then
        rslt[infop_n] = {func = infop_name, expected = true }
      elseif sign=="!" then
        rslt[infop_n] = {func = infop_name, expected = false }
      else
        abort_syntax_error_in_cond(npc, section, field)
      end
      infop_n = infop_n + 1
    end
  end
end

function parse_func_params(str)
  local lst = {}
  local n
  for par in string.gfind(str, "%s*([^:]+)%s*") do
    n = tonumber(par)
    if n then table.insert(lst, n)
    else table.insert(lst, par) end
  end
  return lst
end

function parse_infop(rslt, str)
  if str then
    local infop_name, sign
    local infop_n = 1
    local at, params
    for s in string.gfind(str, "%s*([%-%+%~%=%!][^%-%+%~%=%!%s]+)%s*") do
      sign = string.sub(s, 1, 1)
      infop_name = string.sub(s, 2)
      params = nil

      -- парсим параметры функций
      at = string.find(infop_name, "%(")
      if at then
        if string.sub(infop_name, -1)~=")" then
          ODS("[~T].~C0Cwrong condlist %s", str)
        end
        if at < string.len(infop_name) - 1 then
          params = parse_func_params(string.sub(infop_name, at + 1, -2))
        else
          params = {}
        end
        infop_name = string.sub(infop_name, 1, at - 1)
      end

      if sign=="+" then
        rslt[infop_n] = {name = infop_name, required = true }
      elseif sign=="-" then
        rslt[infop_n] = {name = infop_name, required = false }
      elseif sign=="~" then
        rslt[infop_n] = {prob = tonumber(infop_name) }
      elseif sign=="=" then
        rslt[infop_n] = {func = infop_name, expected = true, params = params }
      elseif sign=="!" then
        rslt[infop_n] = {func = infop_name, expected = false, params = params }
      else
        abort_syntax_error_in_cond(npc, section, field)
      end
      infop_n = infop_n + 1
    end
  end
end

-- Распарсивает строку src вида:
-- {+infop1} section1 %-infop2%, {+infop3 -infop4} section2 ...
-- в таблицу:
-- {
--  1 = {infop_check = {1 = {"infop1" = true} }, infop_set = {1 = {"infop2" = false } }, section = "section1" },
--  2 = {infop_check = {1 = {"infop3" = true}, 2 = {"infop4" = false} }, infop_set = {}, section = "section2" },
-- }
function parse_condlist(npc, section, field, src)
  local lst = {}

  -- 1) Разбиваем на разделенные запятыми части:
  local at, to, infop_check_lst, remainings, infop_set_lst, newsect
  local n = 1
  if src then
    for fld in string.gfind(src, "%s*([^,]+)%s*") do
      -- Здесь fld это набор infoportions в {} и имя секции, на которую переключиться.
      lst[n] = {}
      -- Выделяем список infoportions для проверки:
      at, to, infop_check_lst = string.find(fld, "{%s*(.*)%s*}")
      if infop_check_lst then
        -- Выделяем оставшуюся часть поля, т.е. имя секции плюс список infoportions для установки:
        remainings = string.sub(fld, 1, at - 1) .. string.sub(fld, to + 1)
      else
        -- Список infoportions для проверки не был задан, следовательно, ничего не удаляем:
        remainings = fld
      end
      -- Выделяем список infoportions для установки из remainings:
      at, to, infop_set_lst = string.find(remainings, "%%%s*(.*)%s*%%")
      if infop_set_lst then
        -- Выделяем оставшуюся часть поля, т.е. имя секции:
        newsect = string.sub(remainings, 1, at - 1) .. string.sub(remainings, to + 1)
      else
        -- Список infoportions для установки не был задан, следовательно, remainings и есть имя секции.
        newsect = remainings
      end
      -- И сразу trim имя секции:
      at, to, newsect = string.find(newsect, "%s*(.*)%s*")
      if not newsect then
        abort_syntax_error_in_cond(npc, section, field)
      end

      -- Имя секции теперь можно сохранить:
      lst[n].section = newsect

      -- Теперь нужно распарсить infoportions в строке infop_check_lst и
      -- заполнить массив infop_check: {"infop_name" = true/false }.
      -- На входе имеем строку вида "  +infop1  -infop2 +infop3 ... "
      lst[n].infop_check = {}
      parse_infop(lst[n].infop_check, infop_check_lst)

      -- То же самое для устанавливаемых infoportions:
      lst[n].infop_set = {}
      parse_infop(lst[n].infop_set, infop_set_lst)

      n = n + 1
    end
  end
  return lst
end

function cfg_get_number_and_condlist(ini, section, field, npc)
  local str = utils.cfg_get_string(ini, section, field, npc, false, "")
  if not str then
    return nil
  end

  local par = utils.parse_params(str)
  if not par[1] or not par[2] then
    abort_syntax_error_in_cond(npc, section, field)
  end

  local t = {}

  t.name = field
  t.v1 = tonumber(par[1])
  t.condlist = parse_condlist(npc, section, field, par[2])

  return t
end

function cfg_get_string_and_condlist(ini, section, field, npc)
  local str = utils.cfg_get_string(ini, section, field, npc, false, "")
  if not str then
    return nil
  end

  local par = utils.parse_params(str)
  if not par[1] or not par[2] then
    abort_syntax_error_in_cond(npc, section, field)
  end

  local t = {}

  t.name = field
  t.v1 = par[1]
  t.condlist = parse_condlist(npc, section, field, par[2])

  return t
end

function cfg_get_two_strings_and_condlist(ini, section, field, npc)
  local str = utils.cfg_get_string(ini, section, field, npc, false, "")
  if not str then
    return nil
  end

  local par = utils.parse_params(str)
  if not par[1] or not par[2] or not par[3] then
    abort_syntax_error_in_cond(npc, section, field)
  end

  local t = {}

  t.name = field
  t.v1 = par[1]
  t.v2 = par[2]
  t.condlist = parse_condlist(npc, section, field, par[3])

  return t
end

function cfg_get_condlist(ini, section, field, npc)
    
  local str = utils.cfg_get_string(ini, section, field, npc, false, "")
  if not str then
    return nil
  end
    
  local par = utils.parse_params(str)
  if not par[1] then
    abort_syntax_error_in_cond(npc, section, field)
  end

  local t = {} 

  t.name = field
  t.condlist = parse_condlist(npc, section, field, par[1])
  return t
end

function add_condition(lst, at, cond)
  if cond then
    lst[at] = cond
    return at + 1
  end
  return at
end


function cfg_get_switch_conditions(ini, section, npc)
  local l = {}
  local t
  local n = 1

  local function add_conditions(func, cond)
    local i = 1
    local c = func(ini, section, cond, npc)

    while c~=nil do
      n = add_condition(l, n, c, npc)

      i = i + 1

      c = func(ini, section, cond..i, npc)
    end
  end

  add_conditions(cfg_get_number_and_condlist, "on_actor_dist_le")
  add_conditions(cfg_get_number_and_condlist, "on_actor_dist_le_nvis")
  add_conditions(cfg_get_number_and_condlist, "on_actor_dist_ge")
  add_conditions(cfg_get_number_and_condlist, "on_actor_dist_ge_nvis")
  add_conditions(cfg_get_string_and_condlist, "on_signal")
  add_conditions(cfg_get_condlist, "on_info")
  add_conditions(cfg_get_number_and_condlist, "on_timer")
  add_conditions(cfg_get_number_and_condlist, "on_game_timer")
  add_conditions(cfg_get_string_and_condlist, "on_actor_in_zone")
  add_conditions(cfg_get_string_and_condlist, "on_actor_not_in_zone")
  add_conditions(cfg_get_condlist, "on_actor_inside")
  add_conditions(cfg_get_condlist, "on_actor_outside")
  add_conditions(cfg_get_npc_and_zone, "on_npc_in_zone")
  add_conditions(cfg_get_npc_and_zone, "on_npc_not_in_zone")

  return l
end

function cfg_get_overrides(ini, section, npc)
  local l = {}
--  l.meet_enabled      = utils.cfg_get_bool(ini, section, "meet_enabled", npc, false)
--  l.meet_talk_enabled = utils.cfg_get_bool(ini, section, "meet_talk_enabled", npc, false)
--  l.meet_dialog      = utils.cfg_get_string(ini, section, "meet_dialog", npc, false, "")
--  l.meet_state        = utils.cfg_get_string(ini, section, "meet_state", npc, false, "")
--  l.reactions        = parse_names(utils.cfg_get_string(ini, section, "reactions", npc, false, "", ""))

  local tmp    = utils.cfg_get_string(ini, section, "heli_hunter", npc, false, "")
  if tmp then
    l.heli_hunter = xr_logic.parse_condlist(npc, section, "heli_hunter", tmp)
  end

--  l.wounded_enabled  = utils.cfg_get_bool(ini, section, "wounded_enabled", npc, false)
  l.combat_ignore    = cfg_get_condlist(ini, section, "combat_ignore_cond", npc)
  l.combat_ignore_keep_when_attacked = utils.cfg_get_bool(ini, section, "combat_ignore_keep_when_attacked", npc, false)
  l.combat_type      = cfg_get_condlist(ini, section, "combat_type", npc)
  l.on_combat        = cfg_get_condlist(ini, section, "on_combat", npc)
  l.companion_enabled = utils.cfg_get_bool(ini, section, "companion_enabled", npc, false)

  if string.find(section, "kamp",1,true)~=nil then
    l.soundgroup    = utils.cfg_get_string(ini, section, "center_point", npc, false, "")
  else
    l.soundgroup    = utils.cfg_get_string(ini, section, "soundgroup", npc, false, "")
  end


  return l
end

function cfg_get_npc_and_zone(ini, section, field, npc)
  local t = cfg_get_two_strings_and_condlist(ini, section, field, npc)

  if t then
    local sim = alife()
    if sim then
      local se_obj = sim:story_object(tonumber(t.v1))
      if se_obj then
        t.npc_id = se_obj.id
      else
        t.npc_id = -1
        --ODS("[~T].~C0Cobject '%s': section '%s': field '%s': there is no object with story_id '%s'",npc:name(), section, field, t.v1)
      end
    else
      t.npc_id = -1
    end
  end

  return t
end

-- Возвращает ссылку на оверрайды, зарегистрированные в активной на данный момент секции,
-- либо nil, если ни одна из секций не активна, или оверрайдов нет.
function generic_scheme_overrides(npc)
  return db.storage[npc:id()].overrides
end

function mob_release(mob)
  if mob:get_script() then
    mob:script(false, script_name())
  end
end

function mob_capture(mob, reset_actions)
  if reset_actions==nil then
    ODS("[~T].~C0Cmob_capture: reset_actions parameter's value is not specified")
  end

  if reset_actions then
    reset_action(mob, script_name())
  else
    if not mob:get_script() then
      mob:script(true, script_name())
    end
  end
end

function mob_captured(mob)
  return mob:get_script()
end


local tPstorFunc_r = {
  [0] = "r_float",
  [1] = "r_stringZ",
  [2] = "r_bool",
  [3] = "r_u16", --/#+#
  [4] = "r_s16"  --/#+#
}
local tPstorFunc_w = {
  ["number"]  = {0, "w_float"},
  ["string"]  = {1, "w_stringZ"},
  ["boolean"] = {2, "w_bool"},
  ["u16"]     = {3, "w_u16"}, --/#+#
  ["s16"]     = {4, "w_s16"}  --/#+#
}

function pstor_is_registered_type(sType)
  if sType == 'number' or sType == 'string' or sType == 'boolean' then
    return true --/>
  end
  return false --/>
end

--/ запись в storage объекта
function pstor_store(oObj, sVarName, Value)
  local idObj = oObj and oObj:id()
  if idObj and sVarName then --/#fix#
  local tStor = db.storage[idObj]
    if Value == nil then --/ стираем
      if tStor.pstor then
      tStor.pstor[sVarName] = nil
      end
      return --/>
    elseif tPstorFunc_w[type(Value)] then
      if not tStor.pstor then tStor.pstor = {} end
      tStor.pstor[sVarName] = Value
      return --/>
    end
  end
  --ODS("[~T].~C0Cpstor_store:Obj=[%s],varname=[%s]:<%s>", oObj and oObj:name(), sVarName, "Error!")
end
--/ чтение из storage объекта
function pstor_retrieve(oObj, sVarName, DefValue)
  local idObj = oObj and oObj:id() --/#fix#
  local tStor = idObj and db.storage[idObj]
  if tStor and tStor.pstor then
    local Value = tStor.pstor[sVarName]
    if Value ~= nil then
      return Value --/>
    end
  end
  return DefValue --/>
end


function save_logic(oObj, packet) --/ не изменяем
  local tStor = db.storage[oObj:id()]
  packet:w_s32( (tStor.activation_time or 0) - time_global() )
  utils.w_CTime(packet, tStor.activation_game_time) --/ GAMETIME added by Stohe.
end

function load_logic(oObj, reader) --/ не изменяем
  local tStor = db.storage[oObj:id()]
  tStor.activation_time = reader:r_s32() + time_global()
  tStor.activation_game_time = utils.r_CTime(reader) --/ GAMETIME added by Stohe.
end

function pstor_save_all(oObj, packet)
  local idObj = oObj:id()
  local tPstor = db.storage[idObj].pstor
  if not tPstor then
    db.storage[idObj].pstor = {}
    packet:w_u32(0) --/< count variables
    return --/>
    elseif next(tPstor) == nil then --/ пустой?
    packet:w_u32(0) --/< count variables
    return --/>
  end
  local iCnt = 0
  for k,v in pairs(tPstor) do
  iCnt = iCnt +1
  end
  packet:w_u32(iCnt) --/< count variables

  local tFunc,oFunc --/#+#
  for k,v in pairs(tPstor) do
  tFunc = tPstorFunc_w[type(v)]
    if tFunc then
      --/#+# если число ("number") - проверим: достаточно ли 2-х байт?
      if tFunc[1] == 0 and v < BAD_OBJ_ID and v > -32768 and v == math.floor(v) then
      --/ проверяем целочисленное число на знак
        if v >= 0 then
          tFunc = tPstorFunc_w["u16"] --/ положительное
        else
          tFunc = tPstorFunc_w["s16"] --/ отрицательное (требуется сохранить и знак)
        end
      end
      packet:w_stringZ(k) --/< name variable
      packet:w_u8(tFunc[1]) --/< type variable
      oFunc = packet[tFunc[2]] --/ write-function
      oFunc(packet,v) --/< value variable
    else
      --ODS("[~T].~C0Cpstor_save_all:not_registered_type=["..type(v).."]<~encountered")
      return --/>
    end
  end
end

function pstor_load_all(oObj, reader)
  local idObj = oObj:id()
  local tPstor = db.storage[idObj].pstor
  if not tPstor then
    tPstor = {}
    db.storage[idObj].pstor = tPstor
  end

  local iCnt = reader:r_u32() --/< count variables
  if iCnt == 0 then
    return --/>
    elseif iCnt > 48 and idObj ~= db.actor:id() then --/#fix# для не актора допустимо не более 48 переменных
    iCnt = 32
  end

  local sVarName,iType,sFunc,oFunc
  for i=1, iCnt do
  sVarName = reader:r_stringZ() --/< name variable
  iType    = reader:r_u8() --/< type variable
  sFunc = tPstorFunc_r[iType] --/ name read-function
    if sFunc then
      oFunc = reader[sFunc] --/ read-function
      tPstor[sVarName] = oFunc(reader) --/< value variable
    else
      tPstor[sVarName] = nil
    end
  end
end

function save_obj(obj, packet)
  local npc_id = obj:id()
  local st = db.storage[npc_id]
  if st.ini_filename then
    packet:w_stringZ(st.ini_filename)
  else
    packet:w_stringZ("")
  end

  if st.section_logic then
    packet:w_stringZ(st.section_logic)
  else
    packet:w_stringZ("")
  end

  if st.active_section then
    packet:w_stringZ(st.active_section)
  else
    packet:w_stringZ("")
  end

  --if st.active_scheme then
  --  packet:w_stringZ(st.active_scheme)
  --else
  --  packet:w_stringZ("")
  --end

  if st.gulag_name then
    packet:w_stringZ(st.gulag_name)
  else
    packet:w_stringZ("")
  end

  --packet:w_s32(st.stype)

  save_logic(obj, packet)

  if st.active_scheme then
    issue_event(obj, db.storage[npc_id][st.active_scheme], "save")
  end

  pstor_save_all(obj, packet)
end

function load_obj(obj, reader)
  local npc_id = obj:id()
  local st = db.storage[npc_id]

  local ini_filename = reader:r_stringZ()
  if ini_filename=="" then
    ini_filename = nil
  end

  local section_logic = reader:r_stringZ()
  if section_logic=="" then
    section_logic = nil
  end

  local active_section = reader:r_stringZ()
  if active_section=="" then
    -- В activate_by_section нужно передать строку "nil", а не nil, чтобы не активировать ни одной из схем.
    -- При этом реальная active_section станет равной nil.
    active_section = "nil"
  end

  --local active_scheme = reader:r_stringZ()
  --if active_scheme=="" then
  --  active_scheme = nil
  --end

  local gulag_name = reader:r_stringZ()
  if gulag_name=="" then
    gulag_name = nil
  end

  --local stype = reader:r_s32()

  st.loaded_ini_filename = ini_filename
  st.loaded_section_logic = section_logic
  st.loaded_active_section = active_section
  --st.loaded_active_scheme = active_scheme
  st.loaded_gulag_name = gulag_name
  --st.loaded_stype = stype
  load_logic(obj, reader)

  pstor_load_all(obj, reader)
end

function get_customdata_or_ini_file(npc, filename)
  --ODS("[~T]. #DBG: customdata ~C0A"..npc:name().."~C07")
  if filename=="<customdata>" then
    local ini = npc:spawn_ini()
    if ini then
      return ini
    else
      return ini_dummy_ltx
    end
  elseif string.find(filename, "*")==1 then
    local p = string.find(filename, "*", 2)
    return gulag_tasks.loadLtx(string.sub(filename, 2, p-1), string.sub(filename, p+1))
  else
    return ini_file(filename)
  end
end

function initialize_obj(obj, st, loaded, actor, stype, inifile)
  if not loaded then
    local ini_filename = inifile or "<customdata>"
    local ini = get_customdata_or_ini_file(obj, ini_filename)
    ini = xr_logic.configure_schemes(obj, ini, ini_filename, stype, "logic", nil)
    local sect = xr_logic.determine_section_to_activate(obj, ini, "logic", actor)
    xr_logic.activate_by_section(obj, ini, sect, false)
  else
    local ini_filename = st.loaded_ini_filename
        
    if ini_filename then
      local ini = get_customdata_or_ini_file(obj, ini_filename)
      ini = xr_logic.configure_schemes(obj, ini, ini_filename, stype, st.loaded_section_logic, st.loaded_gulag_name)
      xr_logic.activate_by_section(obj, ini, st.loaded_active_section, true)
    end

--    if st.active_scheme then
--      issue_event(obj, db.storage[obj:id()][st.active_scheme], "load")
--    end
  end
end
